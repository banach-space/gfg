#!/usr/bin/env python3
"""
Inplements the user-facing interface for gfg

[1] https://git-scm.com/docs/index-format#_cache_tree
"""

import argparse
import sys
import os
from pathlib import Path
from git_repository import GitRepository
from git_index import IndexFile
from git_index import IndexTreeEntry
from gfg_common import GIT_INVALID_ENTRY_COUNT
from gfg_common import GFGError
from git_object import GitBlobObject
from git_object import GitTreeObject
from git_object import GitCommitObject
from git_object import create_git_object

#==============================================================================
# Define the supported commands for the argument parser
#==============================================================================
gfg_parser = argparse.ArgumentParser(
    description="Git From Glasgow")
gfg_subparsers = gfg_parser.add_subparsers(
    title="gfg commands", dest="command")

# `gfg init`
gfg_init_parser = gfg_subparsers.add_parser("init",
    help="Create an empty Git repository or reinitialize an existing one")
gfg_init_parser.add_argument("directory", metavar="directory", nargs="?",
    default=".", help="Where to create the repository.")

# `gfg add`
gfg_add_parser = gfg_subparsers.add_parser("add",
    help="Files to add content from.")
gfg_add_parser.add_argument("files", metavar="files", nargs='+', default=".",
    help="")

# `gfg cat-file`
gfg_cat_file_parser = gfg_subparsers.add_parser("cat-file",
    help="Provide content or type and size information for repository objects")
gfg_cat_file_group = gfg_cat_file_parser.add_mutually_exclusive_group(required=True)
gfg_cat_file_group.add_argument("-p", action="store_true",
    help="Pretty-print the contents of <object> based on its type.")
gfg_cat_file_group.add_argument("-t", action="store_true",
    help="Instead of the content, show the object type identified by <object>.")
gfg_cat_file_group.add_argument("type", metavar="type", nargs='?',
    choices=["blob", "commit", "tag", "tree"], help="Specify the type")
gfg_cat_file_parser.add_argument("object", metavar="object_hash",
    help="The name of the object to show")

# `gfg hash-object`
gfg_hash_object_parser = gfg_subparsers.add_parser("hash-object",
    help="Compute object ID and optionally creates a blob from a file")
gfg_hash_object_parser.add_argument("-w", action="store_true",
    help="Actually write the object into the object database.")
gfg_hash_object_group = gfg_hash_object_parser.add_mutually_exclusive_group(required=True)
gfg_hash_object_group.add_argument("--stdin", action="store_true",
    help="Read the object from standard input instead of from a file")
gfg_hash_object_group.add_argument("file", metavar="file", nargs='?',
    help="")

# `gfg log`
gfg_log_parser = gfg_subparsers.add_parser("log",
    help="Show commit logs")
# Hidden option, not available in `git`. It will disable ASCI escape characters
# in `gfg log` (needed for comparing the output with `git log`).
gfg_log_parser.add_argument("--disable-ascii-escape", action="store_true",
    help=argparse.SUPPRESS)

# `gfg write-tree`
gfg_write_tree_parser = gfg_subparsers.add_parser("write-tree",
    help="Show commit logs")

#==============================================================================
# Implement the supported commands
#==============================================================================
def cmd_init(directory="."):
    """Implements `gfg init`"""
    return GitRepository(directory)

def cmd_add(files, git_repo):
    """Implements `gfg add`"""

    # Check whether the input file exists
    for file_to_add in files:
        input_file = Path(file_to_add)
        if not input_file.exists():
            print(f"fatal: pathspec '{input_file}' did not match any files",
                    file=sys.stderr)
            sys.exit(1)

        index = IndexFile(git_repo.get_git_file_path("index"))
        index.add_file(file_to_add)

        data = GitBlobObject.get_packed_blob(file_to_add)
        blob = GitBlobObject(repo, packed_data=data)
        blob.write()

def create_new_tree(dir_path, git_repo, index):
    """ Creates a new Git tree object

    INPUT:
        dir_path - Directory for which to create this tree object
    RETURN:
        New index tree cache entry corresponding to the newly created Git tree
        object
    """

    # Get blobs in this tree
    blobs_in_tree = index.get_blobs(dir_path)

    # Get sub-dirs in this tree
    subtrees = index.get_subtrees(dir_path)

    new_tree_object = GitTreeObject(git_repo, blobs=blobs_in_tree, trees=subtrees)
    # Need to print to generate sha
    try:
        new_tree_object.save_to_file()
    except GFGError:
        pass

    num_blobs_in_tree = len(blobs_in_tree)
    for tree in subtrees:
        num_blobs_in_tree += tree.entry_count

    return IndexTreeEntry(dir_path, num_blobs_in_tree,
            len(subtrees), new_tree_object.object_hash)

def cmd_write_tree(git_repo):
    """Implements `gfg write-tree`

    INPUT:
        git_repo - Git repository in which to generate this tree object

    Once this is run, all new Git tree objects should be present in
    .git/objects and the Git Index should be up to date.

    """
    index = IndexFile(git_repo.get_git_file_path("index"))

    # 1. Identify dirs/trees to create and/or to update
    new_dirs, dirs_to_update = index.get_trees_to_add_or_update()

    # 2. Create tree objects for the newly added dirs in Index. We need to stick to the order
    # outlined in [1] ("The entries are written out in the top-down, depth-first order."). To this
    # end, sort the directories so that we start with the most nested dir first. For example, for:
    #   * ['test_dir/test_dir_nested', 'test_dir']
    # we need the directories to be ordered like this:
    #   * ['test_dir', 'test_dir/test_dir_nested'].
    # This way we make sure that we insert the parent directory first, and then child dirs.
    new_dirs = list(new_dirs)
    new_dirs.sort()
    dirs_to_update = list(dirs_to_update)
    new_dirs_entries = []
    for dir_path in new_dirs:
        new_tree = IndexTreeEntry(dir_path, GIT_INVALID_ENTRY_COUNT, 0, None)
        new_dirs_entries.append(new_tree)
        index.extension_tree_cache.add_entry(new_tree)
        dirs_to_update.append(dir_path)

    index.update_checksum()
    index.validate(read_file=False)

    # 2. Update all index tree cache entries that are out-of-date (this included the newly created
    # entries in Step 2.). New files that correspond to the new tree objects are created in
    # .git/objects.
    dirs_to_update.sort()
    # Reverse the order of dirs to update. We need this so that for every tree entry we update it's
    # subtrees first.
    dirs_to_update.reverse()
    for dir_path in dirs_to_update:
        new_tree = create_new_tree(dir_path, git_repo, index)
        index.extension_tree_cache.update_tree_entry(new_tree)

    index.update_checksum()
    index.print_to_file()
    index.validate()

    # For compability with `git`, print the new (top) Tree hash
    print(index.extension_tree_cache.get_entries_by_dirname("./")[0].sha)

def cmd_cat_file(object_hash, pretty_print: bool, type_only: bool, this_repo):
    """Implements `gfg cat-file`"""
    gobj = create_git_object(this_repo, sha = object_hash)

    if gobj is not None:
        gobj.print_to_stdout(pretty_print, type_only)
    else:
        print(f"fatal: Not a valid object name {object_hash}")

def cmd_hash_object(this_repo : GitRepository, write_file : bool, file_to_hash=None):
    """Implements `gfg hash-object`

    ARGS:
        this_repo - the Git repo in which to save the file
        write_file - corresponds to `-w` in `gfg hash-object -w <file>`
        file_to_hash - name of the file to calculate the hash for (leave empty
        when reading from stdin)
    """
    data = GitBlobObject.get_packed_blob(file_to_hash)
    blob = GitBlobObject(this_repo, packed_data=data)

    print(blob.object_hash)

    if write_file:
        blob.write()

def cmd_log(this_repo, disable_ascii_escape: bool = False):
    """Implements `gfg log`"""

    # The revision inside `.git/HEAD`
    head_rev = None
    #
    current_commit = None

    # 1. Get the contents of `.git/HEAD`
    head_file_path = os.path.join(this_repo.git_dir, "HEAD")
    with open(head_file_path, "r", encoding = 'utf-8') as head_file:
        file_contents = head_file.read()
        head_rev = file_contents.split(':')[1].lstrip().rstrip()

    # 2. Get the contents of the revision file pointed to in `.git/HEAD`
    # Note: technically speaking, it could be a _revision_ or a _tag_ (perhaps
    # something else that I've missed)
    rev_file_path = os.path.join(this_repo.git_dir, head_rev)
    with open(rev_file_path, "r", encoding = 'utf-8') as rev_file:
        current_commit = rev_file.read().rstrip()

    # 3. Print the logs starting from the most recent commit
    while current_commit is not None:
        commit_obj = GitCommitObject(this_repo, current_commit)

        if not commit_obj.exists:
            print("GFG: The next parent object might be a packfile. "
                    "Packfiles are not supported.", file=sys.stderr)
            return

        commit_obj.print_log(disable_ascii_escape)
        # If there's another commit to display, insert an empty line for
        # consistency with Git.
        if commit_obj.parent_sha is not None:
            print()

        current_commit = commit_obj.parent_sha


#==============================================================================
# Main entry point for the script
#==============================================================================
if __name__ == "__main__":
    args = gfg_parser.parse_args()
    repo = GitRepository.get_repo(".")

    # `gfg init`
    if args.command == "init":
        cmd_init(args.directory)
        sys.exit(0)

    # All other Git commands require the repository to be already initialised
    # and available
    if repo is None:
        print("fatal: not a git repository (or any of the parent directories): .git")
        sys.exit(1)

    if args.command == "add":
        cmd_add(args.files, repo)
    if args.command == "cat-file":
        cmd_cat_file(args.object, args.p, args.t, repo)
    if args.command == "hash-object":
        if args.stdin is False:
            cmd_hash_object(repo, args.w, args.file)
        else:
            cmd_hash_object(repo, args.w)
    if args.command == "log":
        cmd_log(repo, args.disable_ascii_escape)
    if args.command == "write-tree":
        cmd_write_tree(repo)
